[{"name": "app.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport uuid\nimport os\nimport base64\nimport io\nfrom pathlib import Path\nfrom matplotlib.backends.backend_svg import FigureCanvasSVG\nfrom maidr.widget.shiny import render_maidr\nfrom shiny import App, reactive, render, ui\nfrom shiny.types import FileInfo\n\n# Import plot modules\nfrom plots.utils import color_palettes\nfrom plots.histogram import create_histogram, create_custom_histogram\nfrom plots.boxplot import create_boxplot, create_custom_boxplot\nfrom plots.scatterplot import create_scatterplot, create_custom_scatterplot\nfrom plots.barplot import create_barplot, create_custom_barplot\nfrom plots.lineplot import create_lineplot, create_custom_lineplot\nfrom plots.heatmap import create_heatmap, create_custom_heatmap\nfrom plots.multilineplot import generate_multiline_data, create_multiline_plot, create_custom_multiline_plot\nfrom plots.multilayerplot import create_multilayer_plot, create_custom_multilayer_plot\nfrom plots.multipanelplot import create_multipanel_plot, create_custom_multipanel_plot\nfrom plots.candlestick import create_candlestick\n\n# Set random seed\nnp.random.seed(1000)\n\n# Define the UI components for the Shiny application with tabs and sidebar\napp_ui = ui.page_fluid(\n    # Head content for custom CSS and JavaScript\n    ui.head_content(\n        ui.tags.style(\n            \"\"\"\n            body.dark-theme { background-color: #2E2E2E; color: white; }\n            body.light-theme { background-color: white; color: black; }\n        \"\"\"\n        ),\n        ui.tags.script(\n            \"\"\"\n            Shiny.addCustomMessageHandler(\"update_theme\", function(theme) {\n                document.body.classList.toggle(\"dark-theme\", theme === \"Dark\");\n                document.body.classList.toggle(\"light-theme\", theme === \"Light\");\n            });\n        \"\"\"\n        ),\n    ),\n    ui.navset_tab(\n        ui.nav_menu(\n            \"Settings\",\n            ui.nav_control(\n                ui.input_select(\n                    \"theme\", \"Theme:\", choices=[\"Light\", \"Dark\"], selected=\"Light\"\n                )\n            ),\n        ),\n        # Fifth tab: Practice tab with file upload, data types, and custom plot creation\n        ui.nav_panel(\n            \"Create your own Custom Plot\",\n            ui.row(\n                # Left column for file upload, table, and conditional dropdowns (50% width)\n                ui.column(\n                    6,\n                    ui.input_file(\"file_upload\", \"Upload CSV File\", accept=\".csv\"),\n                    ui.output_table(\"data_types\"),\n                    ui.output_ui(\"plot_options\"),  # Conditionally render dropdowns\n                    ui.output_ui(\"variable_input\"),  # Variable input for specific plot\n                ),\n                # Right column for the plot (50% width)\n                ui.column(6, \n                    ui.div(\n                        ui.input_action_button(\"save_svg_button\", \"Save SVG to Downloads\", \n                                              class_=\"btn btn-primary\"),\n                        class_=\"text-center mb-3\"\n                    ),\n                    ui.output_ui(\"create_custom_plot\")\n                ),\n            ),\n        ),\n        # First tab: Histogram with dropdowns and plot\n        ui.nav_panel(\n            \"Histogram\",\n            ui.input_select(\n                \"distribution_type\",\n                \"Select histogram distribution type:\",\n                choices=[\n                    \"Normal Distribution\",\n                    \"Positively Skewed\",\n                    \"Negatively Skewed\",\n                    \"Unimodal Distribution\",\n                    \"Bimodal Distribution\",\n                    \"Multimodal Distribution\",\n                ],\n                selected=\"Normal Distribution\",\n            ),\n            ui.input_select(\n                \"hist_color\",\n                \"Select histogram color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_histogram_output\"),\n        ),\n        # Second tab: Box Plot with a single variable for Tutorial\n        ui.nav_panel(\n            \"Box Plot\",\n            ui.input_select(\n                \"boxplot_type\",\n                \"Select box plot type:\",\n                choices=[\n                    \"Positively Skewed with Outliers\",\n                    \"Negatively Skewed with Outliers\",\n                    \"Symmetric with Outliers\",\n                    \"Symmetric without Outliers\",\n                ],\n                selected=\"Positively Skewed with Outliers\",\n            ),\n            ui.input_select(\n                \"boxplot_color\",\n                \"Select box plot color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_boxplot_output\"),\n        ),\n        # Third tab: Scatter Plot with dropdowns and plot\n        ui.nav_panel(\n            \"Scatter Plot\",\n            ui.input_select(\n                \"scatterplot_type\",\n                \"Select scatter plot type:\",\n                choices=[\n                    \"No Correlation\",\n                    \"Weak Positive Correlation\",\n                    \"Strong Positive Correlation\",\n                    \"Weak Negative Correlation\",\n                    \"Strong Negative Correlation\",\n                ],\n                selected=\"No Correlation\",\n            ),\n            ui.input_select(\n                \"scatter_color\",\n                \"Select scatter plot color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_scatterplot_output\"),\n        ),\n        # Fourth tab: Bar Plot with dropdowns and plot\n        ui.nav_panel(\n            \"Bar Plot\",\n            ui.input_select(\n                \"barplot_color\",\n                \"Select bar plot color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_barplot_output\"),\n        ),\n        # New tab: Line Plot\n        ui.nav_panel(\n            \"Line Plot\",\n            ui.input_select(\n                \"lineplot_type\",\n                \"Select line plot type:\",\n                choices=[\n                    \"Linear Trend\",\n                    \"Exponential Growth\",\n                    \"Sinusoidal Pattern\",\n                    \"Random Walk\",\n                ],\n                selected=\"Linear Trend\",\n            ),\n            ui.input_select(\n                \"lineplot_color\",\n                \"Select line plot color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_lineplot_output\"),\n        ),\n        # New tab: Heatmap\n        ui.nav_panel(\n            \"Heatmap\",\n            ui.input_select(\n                \"heatmap_type\",\n                \"Select heatmap type:\",\n                choices=[\n                    \"Random\",\n                    \"Correlated\",\n                    \"Checkerboard\",\n                ],\n                selected=\"Random\",\n            ),\n            ui.output_ui(\"create_heatmap_output\"),\n        ),\n        # New tab: Multiline Plot\n        ui.nav_panel(\n            \"Multiline Plot\",\n            ui.input_select(\n                \"multiline_type\",\n                \"Select multiline plot type:\",\n                choices=[\n                    \"Simple Trends\",\n                    \"Seasonal Patterns\",\n                    \"Growth Comparison\",\n                    \"Random Series\",\n                ],\n                selected=\"Simple Trends\",\n            ),\n            ui.input_select(\n                \"multiline_color\",\n                \"Select color palette:\",\n                choices=[\"Default\", \"Colorful\", \"Pastel\", \"Dark Tones\", \"Paired Colors\", \"Rainbow\"],\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_multiline_plot_output\"),\n        ),\n        # New tab: Multilayer Plot\n        ui.nav_panel(\n            \"Multilayer Plot\",\n            ui.input_select(\n                \"multilayer_background_type\",\n                \"Select background plot type:\",\n                choices=[\n                    \"Bar Plot\",\n                    \"Histogram\",\n                    \"Scatter Plot\"\n                ],\n                selected=\"Bar Plot\",\n            ),\n            ui.input_select(\n                \"multilayer_background_color\",\n                \"Select background color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.input_select(\n                \"multilayer_line_color\",\n                \"Select line color:\",\n                choices=list(color_palettes.keys()),\n                selected=\"Default\",\n            ),\n            ui.output_ui(\"create_multilayer_plot_output\"),\n        ),\n        \n        # New tab: Multipanel Plot\n        ui.nav_panel(\n            \"Multipanel Plot\",\n            ui.p(\"Three-panel plot with line plot and bar plots\"),\n            ui.output_ui(\"create_multipanel_plot_output\"),\n        ),\n        \n        # New tab: Candlestick Chart\n        ui.nav_panel(\n            \"Candlestick Chart\",\n            ui.input_select(\n                \"candlestick_company\",\n                \"Select company:\",\n                choices=[\n                    \"Tesla\",\n                    \"Apple\", \n                    \"NVIDIA\",\n                    \"Microsoft\",\n                    \"Google\",\n                    \"Amazon\",\n                ],\n                selected=\"Tesla\",\n            ),\n            ui.input_select(\n                \"candlestick_timeframe\",\n                \"Select timeframe:\",\n                choices=[\n                    \"Daily\",\n                    \"Monthly\",\n                    \"Yearly\",\n                ],\n                selected=\"Daily\",\n            ),\n            ui.output_ui(\"create_candlestick_output\"),\n        ),\n        \n    ),\n)\n\n\n# Define the server logic\ndef server(input, output, session):\n    uploaded_data = reactive.Value(None)\n    # Add a reactive value to store multiline plot data\n    multiline_data = reactive.Value(None)\n    # Add reactive value to store the current figure\n    current_figure = reactive.Value(None)\n\n    # Update the theme based on the selected option\n    @reactive.effect\n    @reactive.event(input.theme)\n    async def update_theme():\n        await session.send_custom_message(\"update_theme\", input.theme())\n\n    # Histogram Plot\n    @output\n    @render_maidr\n    def create_histogram_output():\n        # Explicitly reference all relevant inputs for reactivity\n        distribution_type = input.distribution_type()\n        hist_color = input.hist_color()\n        theme = input.theme()\n        return create_histogram(distribution_type, hist_color, theme)\n\n    # Box Plot\n    @output\n    @render_maidr\n    def create_boxplot_output():\n        boxplot_type = input.boxplot_type()\n        boxplot_color = input.boxplot_color()\n        theme = input.theme()\n        return create_boxplot(boxplot_type, boxplot_color, theme)\n\n    # Scatter Plot\n    @output\n    @render_maidr\n    def create_scatterplot_output():\n        scatterplot_type = input.scatterplot_type()\n        scatter_color = input.scatter_color()\n        theme = input.theme()\n        return create_scatterplot(scatterplot_type, scatter_color, theme)\n\n    # Bar Plot\n    @output\n    @render_maidr\n    def create_barplot_output():\n        barplot_color = input.barplot_color()\n        theme = input.theme()\n        return create_barplot(barplot_color, theme)\n\n    # Line Plot\n    @output\n    @render_maidr\n    def create_lineplot_output():\n        lineplot_type = input.lineplot_type()\n        lineplot_color = input.lineplot_color()\n        theme = input.theme()\n        return create_lineplot(lineplot_type, lineplot_color, theme)\n\n    # Heatmap\n    @output\n    @render_maidr\n    def create_heatmap_output():\n        heatmap_type = input.heatmap_type()\n        theme = input.theme()\n        return create_heatmap(heatmap_type, theme)\n\n    # Multiline Plot\n    # First, create a reactive calculation for the multiline data\n    @reactive.Calc\n    def get_multiline_data():\n        return generate_multiline_data(input.multiline_type())\n    \n    @output\n    @render_maidr\n    def create_multiline_plot_output():\n        # Explicitly reference all relevant inputs for reactivity\n        multiline_type = input.multiline_type()\n        multiline_color = input.multiline_color()\n        theme = input.theme()\n        # Get the data using the reactive calculation\n        data = get_multiline_data()\n        return create_multiline_plot(data, multiline_type, multiline_color, theme)\n\n    # Multilayer Plot\n    @output\n    @render_maidr\n    def create_multilayer_plot_output():\n        multilayer_background_type = input.multilayer_background_type()\n        multilayer_background_color = input.multilayer_background_color()\n        multilayer_line_color = input.multilayer_line_color()\n        theme = input.theme()\n        return create_multilayer_plot(\n            multilayer_background_type, \n            multilayer_background_color, \n            multilayer_line_color, \n            theme\n        )\n\n    # Multipanel Plot\n    @output\n    @render_maidr\n    def create_multipanel_plot_output():\n        theme = input.theme()\n        return create_multipanel_plot(\"Column\", \"Default\", theme)\n\n    # Candlestick Chart\n    @output\n    @render_maidr \n    def create_candlestick_output():\n        try:\n            candlestick_company = input.candlestick_company()\n            candlestick_timeframe = input.candlestick_timeframe()\n            theme = input.theme()\n            \n            # Create the candlestick plot\n            ax = create_candlestick(candlestick_company, candlestick_timeframe, theme)\n            \n            if ax is None:\n                return None\n            # For MAIDR rendering, return the axes object directly\n            return ax\n            \n        except Exception as e:\n            return None\n\n    # Practice Tab Logic\n    @reactive.Effect\n    @reactive.event(input.file_upload)\n    def update_variable_choices():\n        file: list[FileInfo] = input.file_upload()\n        if file and len(file) > 0:\n            df = pd.read_csv(file[0][\"datapath\"])\n            uploaded_data.set(df)\n            numeric_vars = df.select_dtypes(include=np.number).columns.tolist()\n            categorical_vars = df.select_dtypes(include=\"object\").columns.tolist()\n\n            # Update dropdown choices for plots in Practice tab\n            ui.update_select(\n                \"plot_type\",\n                choices=[\n                    \"\",\n                    \"Histogram\",\n                    \"Box Plot\",\n                    \"Scatter Plot\",\n                    \"Bar Plot\",\n                    \"Line Plot\",\n                    \"Heatmap\",\n                    \"Multiline Plot\",\n                    \"Multilayer Plot\",\n                    \"Multipanel Plot\"\n                ],\n            )\n            ui.update_select(\"var_boxplot_x\", choices=[\"\"] + numeric_vars)\n            ui.update_select(\"var_boxplot_y\", choices=[\"\"] + categorical_vars)\n\n    @output\n    @render.table\n    def data_types():\n        df = uploaded_data.get()\n        if df is not None:\n            data_summary = pd.DataFrame(\n                {\n                    \"Variable\": df.columns,\n                    \"Data Type\": df.dtypes.astype(str).replace(\n                        {\n                            \"object\": \"categorical\",\n                            \"int64\": \"numeric\",\n                            \"float64\": \"numeric\",\n                        }\n                    ),\n                }\n            )\n            return data_summary\n\n    @output\n    @render.ui\n    def plot_options():\n        df = uploaded_data.get()\n        if df is not None:\n            return ui.div(\n                ui.input_select(\n                    \"plot_type\",\n                    \"Select plot type:\",\n                    choices=[\n                        \"\",\n                        \"Histogram\",\n                        \"Box Plot\",\n                        \"Scatter Plot\",\n                        \"Bar Plot\",\n                        \"Line Plot\",\n                        \"Heatmap\",\n                        \"Multiline Plot\",\n                        \"Multilayer Plot\",\n                        \"Multipanel Plot\"\n                    ],\n                    selected=\"\",\n                ),\n                ui.input_select(\n                    \"plot_color\",\n                    \"Select plot color:\",\n                    choices=list(color_palettes.keys()),\n                    selected=\"Default\",\n                ),\n            )\n        return ui.div()\n\n    @output\n    @render.ui\n    def variable_input():\n        df = uploaded_data.get()\n        plot_type = input.plot_type()\n\n        if df is not None and plot_type:\n            numeric_vars = df.select_dtypes(include=np.number).columns.tolist()\n            categorical_vars = df.select_dtypes(include=\"object\").columns.tolist()\n            all_vars = df.columns.tolist()\n\n            if plot_type == \"Histogram\":\n                return ui.input_select(\n                    \"var_histogram\",\n                    \"Select variable for Histogram:\",\n                    choices=[\"\"] + numeric_vars,\n                )\n            elif plot_type == \"Box Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_boxplot_x\",\n                        \"Select numerical variable for X-axis:\",\n                        choices=[\"\"] + numeric_vars,\n                    ),\n                    ui.input_select(\n                        \"var_boxplot_y\",\n                        \"Select categorical variable for Y-axis (optional):\",\n                        choices=[\"\"] + categorical_vars,\n                        selected=\"\",\n                    ),\n                )\n            elif plot_type == \"Scatter Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_scatter_x\",\n                        \"Select X variable:\",\n                        choices=[\"\"] + numeric_vars,\n                    ),\n                    ui.output_ui(\"var_scatter_y_output\"),\n                )\n            elif plot_type == \"Bar Plot\":\n                return ui.input_select(\n                    \"var_bar_plot\",\n                    \"Select variable for Bar Plot:\",\n                    choices=[\"\"] + categorical_vars,\n                )\n            elif plot_type == \"Line Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_line_x\", \n                        \"Select X variable:\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.output_ui(\"var_line_y_output\"),\n                )\n            elif plot_type == \"Heatmap\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_heatmap_x\", \n                        \"Select X variable (categorical):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.input_select(\n                        \"var_heatmap_y\", \n                        \"Select Y variable (categorical):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.input_select(\n                        \"var_heatmap_value\", \n                        \"Select value variable (numeric):\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"heatmap_colorscale\",\n                        \"Select color palette:\",\n                        choices=[\"YlOrRd\", \"viridis\", \"plasma\", \"inferno\", \"RdBu_r\", \"coolwarm\"],\n                        selected=\"YlOrRd\",\n                    )\n                )\n            elif plot_type == \"Multiline Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_multiline_x\", \n                        \"Select X variable (numeric):\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.output_ui(\"var_multiline_y_output\"),\n                    ui.input_select(\n                        \"var_multiline_group\", \n                        \"Select grouping variable (categorical):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.input_select(\n                        \"multiline_palette\",\n                        \"Select color palette:\",\n                        choices=[\"Default\", \"Colorful\", \"Pastel\", \"Dark Tones\", \"Paired Colors\", \"Rainbow\"],\n                        selected=\"Default\",\n                    )\n                )\n            elif plot_type == \"Multilayer Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"var_multilayer_x\", \n                        \"Select X variable (categorical):\", \n                        choices=[\"\"] + categorical_vars + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"var_multilayer_background\", \n                        \"Select Background variable (numeric):\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"var_multilayer_line\", \n                        \"Select Line variable (numeric):\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"multilayer_background_type\", \n                        \"Select background plot type:\", \n                        choices=[\"Bar Plot\", \"Histogram\", \"Scatter Plot\"],\n                        selected=\"Bar Plot\"\n                    ),\n                    ui.input_select(\n                        \"multilayer_background_color\",\n                        \"Select background color:\",\n                        choices=list(color_palettes.keys()),\n                        selected=\"Default\",\n                    ),\n                    ui.input_select(\n                        \"multilayer_line_color\",\n                        \"Select line color:\",\n                        choices=list(color_palettes.keys()),\n                        selected=\"Default\",\n                    )\n                )\n            elif plot_type == \"Multipanel Plot\":\n                return ui.div(\n                    ui.input_select(\n                        \"multipanel_layout_custom\", \n                        \"Select layout type:\", \n                        choices=[\"Grid 2x2\", \"Row\", \"Column\", \"Mixed\"],\n                        selected=\"Grid 2x2\"\n                    ),\n                    ui.input_select(\n                        \"multipanel_color_custom\",\n                        \"Select color palette:\",\n                        choices=[\"Default\", \"Colorful\", \"Pastel\", \"Dark Tones\", \"Paired Colors\", \"Rainbow\"],\n                        selected=\"Default\",\n                    ),\n                    ui.h4(\"Subplot 1:\"),\n                    ui.input_select(\n                        \"multipanel_plot1_type\", \n                        \"Plot type:\", \n                        choices=[\"line\", \"bar\", \"scatter\", \"hist\", \"multiline\"],\n                        selected=\"line\"\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot1_x\", \n                        \"X variable:\", \n                        choices=[\"\"] + all_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot1_y\", \n                        \"Y variable:\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot1_group\", \n                        \"Group variable (for multiline):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.h4(\"Subplot 2:\"),\n                    ui.input_select(\n                        \"multipanel_plot2_type\", \n                        \"Plot type:\", \n                        choices=[\"line\", \"bar\", \"scatter\", \"hist\", \"multiline\"],\n                        selected=\"bar\"\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot2_x\", \n                        \"X variable:\", \n                        choices=[\"\"] + all_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot2_y\", \n                        \"Y variable:\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot2_group\", \n                        \"Group variable (for multiline):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.h4(\"Subplot 3:\"),\n                    ui.input_select(\n                        \"multipanel_plot3_type\", \n                        \"Plot type:\", \n                        choices=[\"line\", \"bar\", \"scatter\", \"hist\", \"multiline\"],\n                        selected=\"scatter\"\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot3_x\", \n                        \"X variable:\", \n                        choices=[\"\"] + all_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot3_y\", \n                        \"Y variable:\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot3_group\", \n                        \"Group variable (for multiline):\", \n                        choices=[\"\"] + categorical_vars\n                    ),\n                    ui.h4(\"Subplot 4:\"),\n                    ui.input_select(\n                        \"multipanel_plot4_type\", \n                        \"Plot type:\", \n                        choices=[\"line\", \"bar\", \"scatter\", \"hist\", \"multiline\"],\n                        selected=\"hist\"\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot4_x\", \n                        \"X variable:\", \n                        choices=[\"\"] + all_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot4_y\", \n                        \"Y variable:\", \n                        choices=[\"\"] + numeric_vars\n                    ),\n                    ui.input_select(\n                        \"multipanel_plot4_group\", \n                        \"Group variable (for multiline):\", \n                        choices=[\"\"] + categorical_vars\n                    )\n                )\n        return ui.div()\n\n    # Dynamic Y variable selection for Scatter Plot\n    @output\n    @render.ui\n    def var_scatter_y_output():\n        df = uploaded_data.get()\n        if df is not None:\n            x_var = input.var_scatter_x()\n            y_choices = [\"\"] + [\n                var\n                for var in df.select_dtypes(include=np.number).columns\n                if var != x_var\n            ]\n            return ui.input_select(\n                \"var_scatter_y\", \"Select Y variable:\", choices=y_choices\n            )\n        return ui.div()\n\n    # Dynamic Y variable selection for Line Plot\n    @output\n    @render.ui\n    def var_line_y_output():\n        df = uploaded_data.get()\n        if df is not None:\n            x_var = input.var_line_x()\n            y_choices = [\"\"] + [\n                var\n                for var in df.select_dtypes(include=np.number).columns\n                if var != x_var\n            ]\n            return ui.input_select(\n                \"var_line_y\", \"Select Y variable:\", choices=y_choices\n            )\n        return ui.div()\n\n    # Dynamic Y variable selection for Multiline Plot\n    @output\n    @render.ui\n    def var_multiline_y_output():\n        df = uploaded_data.get()\n        if df is not None:\n            x_var = input.var_multiline_x()\n            y_choices = [\"\"] + [\n                var\n                for var in df.select_dtypes(include=np.number).columns\n                if var != x_var\n            ]\n            return ui.input_select(\n                \"var_multiline_y\", \"Select Y variable:\", choices=y_choices\n            )\n        return ui.div()\n\n    @output\n    @render_maidr\n    def create_custom_plot():\n        df = uploaded_data.get()\n        plot_type = input.plot_type()\n        color = color_palettes[input.plot_color()]\n        theme = input.theme()\n\n        if df is None or not plot_type:\n            return None\n\n        try:\n            fig = plt.figure()\n            if plot_type == \"Histogram\":\n                var = input.var_histogram()\n                result = create_custom_histogram(df, var, color, theme)\n                # Store the figure for download\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Box Plot\":\n                var_x = input.var_boxplot_x()\n                var_y = input.var_boxplot_y()\n                result = create_custom_boxplot(df, var_x, var_y, color, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Scatter Plot\":\n                var_x = input.var_scatter_x()\n                var_y = input.var_scatter_y()\n                result = create_custom_scatterplot(df, var_x, var_y, color, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Bar Plot\":\n                var = input.var_bar_plot()\n                result = create_custom_barplot(df, var, color, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Line Plot\":\n                var_x = input.var_line_x()\n                var_y = input.var_line_y()\n                result = create_custom_lineplot(df, var_x, var_y, color, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Heatmap\":\n                var_x = input.var_heatmap_x()\n                var_y = input.var_heatmap_y()\n                var_value = input.var_heatmap_value()\n                colorscale = input.heatmap_colorscale()\n                result = create_custom_heatmap(df, var_x, var_y, var_value, colorscale, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Multiline Plot\":\n                var_x = input.var_multiline_x()\n                var_y = input.var_multiline_y()\n                var_group = input.var_multiline_group()\n                palette = input.multiline_palette()\n                result = create_custom_multiline_plot(df, var_x, var_y, var_group, palette, theme)\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Multilayer Plot\":\n                var_x = input.var_multilayer_x()\n                var_background = input.var_multilayer_background()\n                var_line = input.var_multilayer_line()\n                background_type = input.multilayer_background_type()\n                background_color = input.multilayer_background_color()\n                line_color = input.multilayer_line_color()\n                result = create_custom_multilayer_plot(\n                    df, var_x, var_background, var_line, background_type, \n                    background_color, line_color, theme\n                )\n                current_figure.set(plt.gcf())\n                return result\n                \n            elif plot_type == \"Multipanel Plot\":\n                # Create config dictionary for multipanel plot\n                vars_config = {\n                    'plot1': {\n                        'type': input.multipanel_plot1_type(),\n                        'x': input.multipanel_plot1_x(),\n                        'y': input.multipanel_plot1_y(),\n                        'group': input.multipanel_plot1_group()\n                    },\n                    'plot2': {\n                        'type': input.multipanel_plot2_type(),\n                        'x': input.multipanel_plot2_x(),\n                        'y': input.multipanel_plot2_y(),\n                        'group': input.multipanel_plot2_group()\n                    },\n                    'plot3': {\n                        'type': input.multipanel_plot3_type(),\n                        'x': input.multipanel_plot3_x(),\n                        'y': input.multipanel_plot3_y(),\n                        'group': input.multipanel_plot3_group()\n                    },\n                    'plot4': {\n                        'type': input.multipanel_plot4_type(),\n                        'x': input.multipanel_plot4_x(),\n                        'y': input.multipanel_plot4_y(),\n                        'group': input.multipanel_plot4_group()\n                    }\n                }\n                \n                layout_type = input.multipanel_layout_custom()\n                color_palette = input.multipanel_color_custom()\n                \n                result = create_custom_multipanel_plot(\n                    df, vars_config, layout_type, color_palette, theme\n                )\n                current_figure.set(plt.gcf())\n                return result\n                \n            return None\n        except Exception as e:\n            print(f\"Error generating plot: {str(e)}\")\n            return None\n\n    # Handle saving SVG to Downloads folder\n    @reactive.effect\n    @reactive.event(input.save_svg_button)\n    def save_svg_to_downloads():\n        # Get the current figure\n        fig = current_figure.get()\n        \n        if fig is None:\n            ui.notification_show(\"No plot available to save\", type=\"warning\")\n            return\n        \n        try:\n            # Create a unique filename with timestamp\n            plot_type = input.plot_type() if input.plot_type() else \"plot\"\n            filename = f\"{plot_type.lower().replace(' ', '_')}_{uuid.uuid4().hex[:8]}.svg\"\n            \n            # Get the Downloads folder path\n            downloads_folder = str(Path.home() / \"Downloads\")\n            filepath = os.path.join(downloads_folder, filename)\n            \n            # Save the figure directly, avoid temporary figure creation\n            fig.savefig(filepath, format='svg', bbox_inches='tight')\n            \n            ui.notification_show(f\"Plot saved to Downloads as {filename}\", type=\"success\")\n        except Exception as e:\n            ui.notification_show(f\"Error saving plot: {str(e)}\", type=\"error\")\n            print(f\"Error saving SVG: {str(e)}\")\n\n\n# Create the app\napp = App(app_ui, server)\n\n# Run the app\nif __name__ == \"__main__\":\n    app.run()\n", "type": "text"}, {"name": "README.md", "content": "# Running the Shiny App Locally\n\nThis guide will walk you through setting up and running the Shiny app using Python, based on the structure of your directory.\n\n### Prerequisites\n1. **Python 3.7+**: Ensure you have Python installed. You can check this by running:\n   ```bash\n   python --version\n   ```\n   If you don\u2019t have it installed, download Python [here](https://www.python.org/downloads/).\n\n2. **Shiny for Python**: You will need to install `shiny`, which is Posit\u2019s package for Python.\n\n3. **Virtual Environment (optional but recommended)**: Using a virtual environment is a good practice to isolate dependencies.\n\n### Steps to Run the App\n\n#### 1. Clone or Navigate to the Directory\nFirst, make sure you are in the directory containing the app files. If you need to clone a GitHub repository, use:\n```bash\ngit clone <repository-url>\ncd <repository-folder>\n```\n\n#### 2. Set up a Virtual Environment (Optional)\nTo avoid dependency conflicts, set up a virtual environment in the directory. \n\n1. **Create a virtual environment**:\n   ```bash\n   python -m venv venv\n   ```\n\n2. **Activate the virtual environment**:\n   - On Windows:\n     ```bash\n     venv\\Scripts\\activate\n     ```\n   - On macOS/Linux:\n     ```bash\n     source venv/bin/activate\n     ```\n\n#### 3. Install Dependencies\nInstall `shiny` and other necessary dependencies specified in the `requirements.txt` file.\n\n1. **Install `shiny`**:\n   ```bash\n   pip install shiny\n   ```\n\n2. **Install the other dependencies**:\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n#### 4. Run the App\nOnce all dependencies are installed, you can run the Shiny app.\n\n1. Run the app:\n   ```bash\n   shiny run --reload app.py\n   ```\n\n   The `--reload` option allows for automatic reloading of the app if you make any code changes.\n\n2. After running the command, you should see output like:\n   ```bash\n   Listening on http://127.0.0.1:8000\n   ```\n\n3. Open the provided URL (`http://127.0.0.1:8000`) in your browser to access the Shiny app.\n\n### Additional Notes:\n- **Dummy Data**: The file `dummy_data_for_practice.csv` is included for you to test the app\u2019s functionality with dummy data. Please free to use your own data!\n- **VS Code Configuration**: If you use VS Code, you may want to install the `Shiny for Python` extension, which will help you run the app and display the content in an in-window browser.\n\n## Running the Shiny App in the Browser with Shinylive (Pyodide)\n\nYou can run this Shiny for Python app entirely in your browser using [Shinylive](https://shinylive.io/py), which uses Pyodide to run Python code client-side (no server needed).\n\n### Steps to Export and Run with Shinylive\n\n1. **Install Shinylive CLI** (if not already installed):\n   ```bash\n   pip install shinylive\n   ```\n\n2. **Export your app for Shinylive:**\n   ```bash\n   shinylive export . output_dir\n   ```\n   This will create an `output_dir` folder with all the files needed to run your app in the browser.\n\n3. **Serve the exported app with a local HTTP server:**\n   ```bash\n   python3 -m http.server --directory output_dir 8008\n   ```\n   Then open [http://localhost:8008](http://localhost:8008) in your browser.\n\n   > **Note:** Opening `index.html` directly (with `file://`) will NOT work due to browser security restrictions. Always use a local HTTP server.\n\n### What is Shinylive/Pyodide?\n- **Shinylive** lets you run Shiny for Python apps in the browser using **Pyodide** (Python compiled to WebAssembly).\n- All computation happens client-side; no server is required after export.\n", "type": "text"}, {"name": "dummy_data_for_practice.csv", "content": "Age,Income,Education,Employment Status,Happiness Score,Hours of Physical Activity\n69,33332.5583260898,Bachelor,Retired,1.1399946551218259,10\n41,38869.91373987022,PhD,Employed,5.7951410446865435,16\n25,88621.38790607327,High School,Unemployed,2.0730464922055845,3\n18,66098.19985769935,Master,Student,2.028888618929105,1\n48,22007.982403993563,PhD,Retired,7.167282283518435,18\n46,40292.346101620176,Master,Student,3.8284870034414955,12\n19,66233.61211069606,Master,Employed,8.053690375108186,13\n18,52650.05473340253,High School,Unemployed,9.580721208028995,7\n43,37470.076508112244,Master,Retired,6.878566850050573,2\n63,24575.025267241792,High School,Retired,9.9617832491356,9\n58,67001.25846765874,PhD,Unemployed,4.36717896292317,1\n59,65727.96084152858,PhD,Retired,4.6922224089494815,12\n46,18075.11944359935,PhD,Unemployed,4.893353156680095,17\n45,28442.90908126696,Bachelor,Student,5.541976153371458,12\n54,52669.056586257335,High School,Student,7.769168829128651,1\n63,70916.34119428959,High School,Student,3.34479405343761,5\n65,54369.802787196684,High School,Unemployed,4.463380246969471,16\n60,48769.907090410125,PhD,Retired,7.673352397325717,0\n59,59663.63918129501,Bachelor,Retired,5.987623056808238,0\n54,54921.199213743595,Bachelor,Student,6.957439084400549,4\n38,62861.491230587024,PhD,Unemployed,5.018172107706221,2\n68,35945.46079228452,Bachelor,Retired,7.68071582888152,17\n48,52701.12433784628,Master,Unemployed,9.895539497247817,19\n59,28649.44120499459,Bachelor,Employed,2.091123160566185,1\n42,44483.66333212928,PhD,Employed,8.0195953853372,16\n68,27150.680152073037,PhD,Unemployed,5.107538475684221,10\n48,40478.42452239212,High School,Retired,3.4555130403472196,19\n46,64811.05762345411,Master,Employed,9.839508732769492,7\n48,34759.70567710834,PhD,Retired,2.301570838484996,18\n31,80685.85620273493,PhD,Unemployed,4.494799724989527,11\n36,53749.97778139087,Master,Retired,7.025428610492258,7\n46,59767.43794597443,High School,Employed,2.949323265748278,9\n39,31009.646917735987,Master,Employed,3.592193882811355,18\n47,70612.33400119815,Master,Employed,4.899904049168818,13\n28,40851.423062656286,Master,Student,8.970410158450163,4\n48,50461.36917766193,Master,Employed,3.932202388797901,0\n32,62294.85015879745,High School,Employed,8.643063452694966,10\n23,71814.7059763356,Bachelor,Retired,3.008268780740027,2\n30,41244.85330377107,PhD,Retired,7.13280685148513,6\n29,56230.21177676359,PhD,Retired,8.943344511051894,18\n29,60005.38666485477,Master,Retired,1.853431548103239,16\n50,63042.42953186868,PhD,Retired,7.369509672144014,1\n68,31959.450101057835,High School,Student,4.3222318383361555,0\n39,92926.53764082892,Master,Employed,6.136203036572402,18\n44,9776.113286541025,PhD,Employed,7.276945456388914,15\n54,32467.82361718624,Master,Unemployed,4.434334895391404,14\n25,41237.536661440725,Bachelor,Retired,4.884980659937531,14\n34,62273.74546112055,PhD,Student,2.7754948931330987,2\n41,73856.55846871909,High School,Employed,1.8253576625244334,16\n46,46125.67651306409,High School,Student,1.746302595596333,5\n61,56705.43558453155,High School,Student,1.5966220850546586,5\n67,79076.29613457836,Master,Retired,5.474293649130869,14\n18,44145.20975089102,Master,Employed,9.246938059576117,11\n49,41289.554936151886,PhD,Employed,2.1459683463500143,4\n48,79234.80456345512,High School,Student,5.571496274155263,4\n63,22061.729849598476,Bachelor,Employed,1.6328399394522495,0\n36,41474.651362669625,Bachelor,Unemployed,6.686865452367478,5\n19,64688.360381028135,PhD,Employed,3.1856613604877237,0\n29,63430.458337924414,High School,Retired,2.2401341959213195,15\n64,46456.06326793763,PhD,Employed,3.1628569709769523,15\n45,56616.468985418585,PhD,Student,4.327117843697822,5\n65,35113.79011276944,Bachelor,Unemployed,8.031624346557418,11\n41,54432.57479186496,High School,Employed,8.00277439018172,11\n33,50632.395407414915,Master,Retired,1.475105821263744,2\n35,61432.085314052274,Bachelor,Student,7.685223386181872,1\n23,59419.34711175786,Master,Student,5.8100261859394,19\n47,51606.848664317724,PhD,Unemployed,2.915285623870116,19\n29,26671.057403782506,Master,Employed,9.7871817189476,1\n30,6412.187374816291,High School,Student,9.344267553946937,0\n23,61336.44250743123,High School,Retired,1.824779147314021,13\n42,30506.5662684538,Master,Student,8.050883000073505,17\n26,37024.662683068775,Master,Student,1.6663508514381098,6\n36,32180.085874063327,PhD,Retired,4.129383295413061,3\n20,35317.78238277712,Master,Student,9.731329547736767,18\n31,20554.98127885621,High School,Retired,5.081703009897058,9\n59,42822.03207845498,PhD,Unemployed,4.36557204114688,17\n24,66233.5411291841,High School,Retired,3.852060724101902,18\n28,66546.30635767957,High School,Retired,9.15310147241281,15\n60,60349.7218220196,High School,Unemployed,8.241146444697556,10\n53,54820.681408433586,High School,Student,8.512974868995935,10\n69,40993.02164088048,Bachelor,Unemployed,6.832633266820297,14\n65,47454.35831250393,PhD,Unemployed,3.1509486918258904,12\n38,29081.474759957004,Master,Unemployed,3.036847610514836,1\n19,46801.27566853797,Bachelor,Retired,5.290806571900116,2\n50,69267.40070081329,Master,Student,4.864918216361547,6\n43,58784.545081573044,PhD,Student,2.4237007494552123,10\n35,41475.91780223528,High School,Retired,2.7628927917259936,17\n58,49342.53200193492,Bachelor,Student,1.2604833445276986,8\n26,64288.801171796134,Bachelor,Employed,6.403633267969196,14\n66,45089.36857924211,Bachelor,Retired,4.7297505534075315,15\n20,43134.526208009156,Bachelor,Unemployed,9.609209601377119,12\n29,55269.890264297865,Bachelor,Student,2.90394177291491,15\n27,44608.41150636335,High School,Employed,4.700998437674185,19\n31,42282.52651202527,Master,Unemployed,5.117217726687683,9\n37,35133.27999373023,PhD,Student,9.740882637578013,18\n32,31440.24270075727,PhD,Retired,1.8836115888279705,14\n65,40062.657068394736,Master,Retired,4.459063151053345,6\n27,61356.53874339946,High School,Retired,5.997246527383623,3\n24,31102.728161796946,PhD,Student,6.474014357575436,16\n36,40010.21086312503,High School,Retired,7.993428775030326,4\n", "type": "text"}, {"name": "requirements.txt", "content": "maidr\nlxml\nshiny\nseaborn\npandas\nmplfinance\nhtmltools\nwrapt", "type": "text"}, {"name": "plots/barplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef create_barplot(input_barplot_color, theme):\n    \"\"\"Create a bar plot based on input parameters\"\"\"\n    color = color_palettes[input_barplot_color]\n    categories = [\"Category A\", \"Category B\", \"Category C\", \"Category D\", \"Category E\"]\n    values = np.random.randint(10, 100, size=5)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.barplot(x=categories, y=values, ax=ax, color=color)\n    ax.set_title(\"Plot of Categories\")\n    ax.set_xlabel(\"Categories\")\n    ax.set_ylabel(\"Values\")\n\n    return ax\n\ndef create_custom_barplot(df, var, color, theme):\n    \"\"\"Create a bar plot from user data\"\"\"\n    if not var or df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.countplot(data=df, x=var, color=color, ax=ax)\n    ax.set_title(f\"{var}\")\n    ax.set_xlabel(var.replace(\"_\", \" \").title())\n    ax.set_ylabel(\"Count\")\n    \n    return ax", "type": "text"}, {"name": "plots/boxplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef create_boxplot(input_boxplot_type, input_boxplot_color, theme):\n    \"\"\"Create a box plot based on input parameters\"\"\"\n    boxplot_type = input_boxplot_type\n    color = color_palettes[input_boxplot_color]\n\n    # Generate data based on the selected box plot type\n    if boxplot_type == \"Positively Skewed with Outliers\":\n        data = np.random.lognormal(mean=0, sigma=0.5, size=1000)\n    elif boxplot_type == \"Negatively Skewed with Outliers\":\n        data = -np.random.lognormal(mean=0, sigma=0.5, size=1000)\n    elif boxplot_type == \"Symmetric with Outliers\":\n        data = np.random.normal(loc=0, scale=1, size=1000)\n    elif boxplot_type == \"Symmetric without Outliers\":\n        data = np.random.normal(loc=0, scale=1, size=1000)\n        data = data[(data > -1.5) & (data < 1.5)]  # Strict range to avoid outliers\n    else:\n        data = np.random.normal(loc=0, scale=1, size=1000)\n\n    # Create the plot using matplotlib\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.boxplot(x=data, ax=ax, color=color)  # Horizontal box plot\n    ax.set_title(f\"{boxplot_type}\")\n    ax.set_xlabel(\"Value\")\n\n    return ax\n\ndef create_custom_boxplot(df, var_x, var_y, color, theme):\n    \"\"\"Create a box plot from user data\"\"\"\n    if df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    if var_x and var_y:\n        sns.boxplot(x=var_y, y=var_x, data=df, palette=[color], ax=ax)\n        ax.set_title(f\"{var_x} grouped by {var_y}\")\n        ax.set_xlabel(var_y.replace(\"_\", \" \").title())\n        ax.set_ylabel(var_x.replace(\"_\", \" \").title())\n    elif var_x:\n        sns.boxplot(y=df[var_x], color=color, ax=ax)\n        ax.set_title(f\"{var_x}\")\n        ax.set_ylabel(var_x.replace(\"_\", \" \").title())\n    else:\n        return None\n        \n    return ax", "type": "text"}, {"name": "plots/candlestick.py", "content": "import matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport numpy as np\nimport pandas as pd\nfrom typing import Dict, List, Optional, Tuple\nfrom plots.utils import set_plot_theme, color_palettes\n\n# Try to import mplfinance, if not available use a fallback\ntry:\n    from mplfinance.original_flavor import candlestick_ohlc\n    MPLFINANCE_AVAILABLE = True\nexcept ImportError:\n    MPLFINANCE_AVAILABLE = False\n    print(\"Warning: mplfinance not available. Using fallback candlestick implementation.\")\n\ndef generate_stock_data(\n    company: str = \"Tesla\",\n    start_date: str = \"2023-01-01\",\n    end_date: str = \"2023-12-31\",\n    seed: Optional[int] = 42,\n) -> Dict[str, List]:\n    \"\"\"\n    Generate sample stock data for different companies.\n    \n    Parameters\n    ----------\n    company : str\n        Company name to determine starting price and volatility\n    start_date : str\n        Start date in YYYY-MM-DD format\n    end_date : str  \n        End date in YYYY-MM-DD format\n    seed : Optional[int]\n        Random seed for reproducibility\n        \n    Returns\n    -------\n    Dict[str, List]\n        Dictionary with OHLCV data\n    \"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Company-specific parameters\n    company_params = {\n        \"Tesla\": {\"start_price\": 200.0, \"volatility\": 0.025},\n        \"Apple\": {\"start_price\": 150.0, \"volatility\": 0.020},\n        \"NVIDIA\": {\"start_price\": 400.0, \"volatility\": 0.030},\n        \"Microsoft\": {\"start_price\": 300.0, \"volatility\": 0.018},\n        \"Google\": {\"start_price\": 2500.0, \"volatility\": 0.022},\n        \"Amazon\": {\"start_price\": 120.0, \"volatility\": 0.024},\n    }\n    \n    params = company_params.get(company, company_params[\"Tesla\"])\n    start_price = params[\"start_price\"]\n    volatility = params[\"volatility\"]\n    \n    # Generate trading dates (weekdays only)\n    all_dates = pd.date_range(start=start_date, end=end_date)\n    trading_dates = all_dates[all_dates.dayofweek < 5]  # Monday to Friday\n    dates = [d.strftime(\"%Y-%m-%d\") for d in trading_dates]\n    \n    opens = []\n    closes = []\n    highs = []\n    lows = []\n    volumes = []\n    \n    current_price = start_price\n    for i in range(len(dates)):\n        if i == 0:\n            opens.append(current_price)\n        else:\n            opens.append(closes[i - 1])\n        \n        # Generate price change with some drift\n        price_change = np.random.normal(0, volatility * opens[i])\n        \n        # Add some mean reversion\n        if opens[i] > start_price * 1.2:\n            price_change -= volatility * opens[i] * 0.1\n        elif opens[i] < start_price * 0.8:\n            price_change += volatility * opens[i] * 0.1\n        \n        close = opens[i] + price_change\n        closes.append(round(close, 2))\n        \n        # Generate high and low\n        daily_range = abs(price_change) + (volatility * opens[i])\n        high = max(opens[i], close) + abs(np.random.normal(0, daily_range / 3))\n        low = min(opens[i], close) - abs(np.random.normal(0, daily_range / 3))\n        \n        highs.append(round(high, 2))\n        lows.append(round(low, 2))\n        \n        # Generate volume\n        base_volume = 1000000\n        vol_factor = 1.0 + 2.0 * (abs(price_change) / (volatility * opens[i]))\n        volume = int(base_volume * vol_factor * np.random.uniform(0.7, 1.3))\n        volumes.append(volume)\n    \n    return {\n        \"Date\": dates,\n        \"Open\": opens,\n        \"High\": highs,\n        \"Low\": lows,\n        \"Close\": closes,\n        \"Volume\": volumes,\n    }\n\ndef draw_candlestick_fallback(ax, ohlc_data, width=0.6, colorup=\"g\", colordown=\"r\"):\n    \"\"\"\n    Fallback function to draw candlesticks when mplfinance is not available.\n    \"\"\"\n    for i, (date_num, open_price, high, low, close) in enumerate(ohlc_data):\n        # Determine color\n        color = colorup if close >= open_price else colordown\n        \n        # Adjust line width based on candlestick width for better visibility\n        line_width = max(1, width / 30) if width > 10 else 1\n        \n        # Draw the high-low line\n        ax.plot([date_num, date_num], [low, high], color=\"black\", linewidth=line_width)\n        \n        # Draw the open-close rectangle\n        height = abs(close - open_price)\n        bottom = min(open_price, close)\n        \n        rect = plt.Rectangle((date_num - width/2, bottom), width, height, \n                           facecolor=color, edgecolor=\"black\", alpha=0.8, \n                           linewidth=line_width)\n        ax.add_patch(rect)\n\ndef create_candlestick_plot(\n    data_dict: Dict[str, List],\n    company: str = \"Tesla\",\n    theme: str = \"Light\",\n    width: float = 0.6,\n    colorup: str = \"g\",\n    colordown: str = \"r\",\n    timeframe: str = \"Daily\",\n) -> plt.Axes:\n    \"\"\"\n    Create a candlestick chart from OHLC data.\n    \n    Parameters\n    ----------\n    data_dict : Dict[str, List]\n        Dictionary with OHLC data\n    company : str\n        Company name for the title\n    theme : str\n        Theme for the plot (Light/Dark)\n    width : float\n        Width of candlesticks\n    colorup : str\n        Color for up days\n    colordown : str\n        Color for down days\n        \n    Returns\n    -------\n    plt.Axes\n        The axes object with the candlestick chart\n    \"\"\"\n    # Validate data\n    array_lengths = [len(arr) for arr in data_dict.values()]\n    if len(set(array_lengths)) > 1:\n        raise ValueError(\"All arrays in data_dict must be of the same length\")\n    \n    df = pd.DataFrame(data_dict)\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    df[\"Date_num\"] = df[\"Date\"].apply(mdates.date2num)\n    \n    # Prepare OHLC data\n    ohlc = df[[\"Date_num\", \"Open\", \"High\", \"Low\", \"Close\"]].values\n    \n    # Create figure and axes\n    fig, ax = plt.subplots(figsize=(12, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    # Plot candlesticks\n    if MPLFINANCE_AVAILABLE:\n        # mplfinance uses width in data units (days)\n        candlestick_ohlc(ax, ohlc, width=width, colorup=colorup, colordown=colordown, alpha=0.8)\n    else:\n        # For fallback, adjust width based on timeframe for better visibility\n        fallback_width = width\n        if timeframe == \"Yearly\":\n            fallback_width = width * 3  # Make it even wider for fallback rendering\n        elif timeframe == \"Monthly\":\n            fallback_width = width * 2\n        draw_candlestick_fallback(ax, ohlc, width=fallback_width, colorup=colorup, colordown=colordown)\n    \n    # Format the plot based on timeframe\n    ax.xaxis_date()\n    \n    if timeframe == \"Daily\":\n        ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y-%m-%d\"))\n        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))\n        plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')\n    elif timeframe == \"Monthly\":\n        ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y-%m\"))\n        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=1))\n        plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')\n    elif timeframe == \"Yearly\":\n        ax.xaxis.set_major_formatter(mdates.DateFormatter(\"%Y\"))\n        ax.xaxis.set_major_locator(mdates.YearLocator())\n        plt.setp(ax.xaxis.get_majorticklabels(), rotation=0, ha='center')\n    \n    ax.grid(True, linestyle=\"--\", alpha=0.6)\n    ax.set_title(f\"{company} Stock Price - Candlestick Chart\", fontsize=14, fontweight='bold')\n    ax.set_xlabel(\"Date\", fontsize=12)\n    ax.set_ylabel(\"Price ($)\", fontsize=12)\n    \n    plt.tight_layout()\n    \n    return ax\n\ndef aggregate_data_by_timeframe(data: Dict[str, List], timeframe: str) -> Dict[str, List]:\n    \"\"\"\n    Aggregate daily data to monthly or yearly timeframes.\n    \n    Parameters\n    ----------\n    data : Dict[str, List]\n        Daily OHLCV data\n    timeframe : str\n        'Daily', 'Monthly', or 'Yearly'\n        \n    Returns\n    -------\n    Dict[str, List]\n        Aggregated OHLCV data\n    \"\"\"\n    if timeframe == \"Daily\":\n        return data\n    \n    df = pd.DataFrame(data)\n    df[\"Date\"] = pd.to_datetime(df[\"Date\"])\n    \n    if timeframe == \"Monthly\":\n        # Group by month and year\n        df['Period'] = df['Date'].dt.to_period('M')\n        grouped = df.groupby('Period')\n        \n        aggregated_data = {\n            'Date': [],\n            'Open': [],\n            'High': [],\n            'Low': [],\n            'Close': [],\n            'Volume': []\n        }\n        \n        for period, group in grouped:\n            # Use the last day of the month as the date\n            aggregated_data['Date'].append(period.end_time.strftime('%Y-%m-%d'))\n            # First day's open price\n            aggregated_data['Open'].append(group.iloc[0]['Open'])\n            # Highest high in the month\n            aggregated_data['High'].append(group['High'].max())\n            # Lowest low in the month\n            aggregated_data['Low'].append(group['Low'].min())\n            # Last day's close price\n            aggregated_data['Close'].append(group.iloc[-1]['Close'])\n            # Sum of volumes\n            aggregated_data['Volume'].append(group['Volume'].sum())\n            \n    elif timeframe == \"Yearly\":\n        # Group by year\n        df['Period'] = df['Date'].dt.to_period('Y')\n        grouped = df.groupby('Period')\n        \n        aggregated_data = {\n            'Date': [],\n            'Open': [],\n            'High': [],\n            'Low': [],\n            'Close': [],\n            'Volume': []\n        }\n        \n        for period, group in grouped:\n            # Use December 31st as the date\n            aggregated_data['Date'].append(period.end_time.strftime('%Y-%m-%d'))\n            # First day's open price\n            aggregated_data['Open'].append(group.iloc[0]['Open'])\n            # Highest high in the year\n            aggregated_data['High'].append(group['High'].max())\n            # Lowest low in the year\n            aggregated_data['Low'].append(group['Low'].min())\n            # Last day's close price\n            aggregated_data['Close'].append(group.iloc[-1]['Close'])\n            # Sum of volumes\n            aggregated_data['Volume'].append(group['Volume'].sum())\n    \n    return aggregated_data\n\ndef create_candlestick(company, timeframe, theme):\n    \"\"\"\n    Create a candlestick plot based on company selection, timeframe, and theme.\n    This function follows the pattern used by other plot modules in the project.\n    \n    MAIDR INTEGRATION NOTE:\n    MAIDR is currently commented out in app.py to ensure the plot renders properly.\n    When MAIDR is working, you can uncomment the @render_maidr decorator \n    and comment out the manual SVG rendering in app.py.\n    \"\"\"\n    # Generate data for the selected company\n    if timeframe == \"Yearly\":\n        # Generate multiple years of data for yearly view\n        data = generate_stock_data(\n            company=company,\n            start_date=\"2018-01-01\", \n            end_date=\"2023-12-31\",\n            seed=42\n        )\n    else:\n        # Use one year of data for daily and monthly views\n        data = generate_stock_data(\n            company=company,\n            start_date=\"2023-01-01\", \n            end_date=\"2023-12-31\",\n            seed=42\n        )\n    \n    # Aggregate data based on timeframe\n    aggregated_data = aggregate_data_by_timeframe(data, timeframe)\n    \n    # Adjust candlestick width based on timeframe\n    if timeframe == \"Daily\":\n        width = 0.6\n    elif timeframe == \"Monthly\":\n        width = 25  # Wider for monthly data (fewer points)\n    elif timeframe == \"Yearly\":\n        width = 200  # Much wider for yearly data (very few points) - about 6-7 months width\n    \n    # Create the candlestick plot\n    title_suffix = f\" - {timeframe} View\"\n    ax = create_candlestick_plot(\n        aggregated_data, \n        company=company + title_suffix, \n        theme=theme,\n        timeframe=timeframe,\n        width=width\n    )\n    \n    return ax ", "type": "text"}, {"name": "plots/heatmap.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport pandas as pd\nfrom plots.utils import set_plot_theme\n\ndef create_heatmap(input_heatmap_type, theme):\n    \"\"\"Create a heatmap based on input parameters\"\"\"\n    heatmap_type = input_heatmap_type\n\n    if heatmap_type == \"Random\":\n        data = np.random.rand(5, 5)  # Reduced size\n    elif heatmap_type == \"Correlated\":\n        data = np.random.multivariate_normal(\n            [0] * 5, np.eye(5), size=5\n        )  # Reduced size\n    elif heatmap_type == \"Checkerboard\":\n        data = np.indices((5, 5)).sum(axis=0) % 2  # Reduced size\n    else:\n        data = np.random.rand(5, 5)\n\n    fig, ax = plt.subplots(figsize=(10, 8))\n    set_plot_theme(fig, ax, theme)\n    sns.heatmap(data, ax=ax, cmap=\"YlGnBu\", annot=True, fmt=\".2f\")\n    ax.set_title(f\"{heatmap_type}\")\n\n    return ax\n\ndef create_custom_heatmap(df, var_x, var_y, var_value, colorscale, theme):\n    \"\"\"Create a heatmap from user data\"\"\"\n    if not var_x or not var_y or df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 8))\n    set_plot_theme(fig, ax, theme)\n    \n    # Check if both variables are categorical and a value variable is provided\n    if var_value:\n        # Create a pivot table\n        pivot_table = pd.pivot_table(df, values=var_value, index=var_y, columns=var_x, aggfunc='mean')\n    else:\n        # If no value variable, use crosstab for frequency counts\n        pivot_table = pd.crosstab(df[var_y], df[var_x], normalize='all')\n    \n    sns.heatmap(pivot_table, ax=ax, cmap=colorscale, annot=True, fmt=\".2f\")\n    ax.set_title(f\"Heatmap of {var_y} vs {var_x}\")\n    ax.set_xlabel(var_x.replace(\"_\", \" \").title())\n    ax.set_ylabel(var_y.replace(\"_\", \" \").title())\n    \n    return ax", "type": "text"}, {"name": "plots/histogram.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef create_histogram(input_distribution_type, input_hist_color, theme):\n    \"\"\"Create a histogram based on input parameters\"\"\"\n    distribution_type = input_distribution_type\n    color = color_palettes[input_hist_color]\n\n    # Generate data based on the selected distribution\n    if distribution_type == \"Normal Distribution\":\n        data = np.random.normal(size=1000)\n    elif distribution_type == \"Positively Skewed\":\n        data = np.random.exponential(scale=3, size=1000)\n    elif distribution_type == \"Negatively Skewed\":\n        data = -np.random.exponential(scale=1.5, size=1000)\n    elif distribution_type == \"Unimodal Distribution\":\n        data = np.random.normal(loc=0, scale=2.5, size=1000)\n    elif distribution_type == \"Bimodal Distribution\":\n        data = np.concatenate(\n            [\n                np.random.normal(-2, 0.5, size=500),\n                np.random.normal(2, 0.5, size=500),\n            ]\n        )\n    elif distribution_type == \"Multimodal Distribution\":\n        data = np.concatenate(\n            [\n                np.random.normal(-2, 0.5, size=300),\n                np.random.normal(2, 0.5, size=300),\n                np.random.normal(5, 0.5, size=400),\n            ]\n        )\n    else:\n        data = np.random.normal(size=1000)\n\n    # Create the plot using matplotlib\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.histplot(data, kde=True, bins=20, color=color, edgecolor=\"white\", ax=ax)\n    ax.set_title(f\"{distribution_type}\")\n    ax.set_xlabel(\"Value\")\n    ax.set_ylabel(\"Frequency\")\n\n    return ax\n    \ndef create_custom_histogram(df, var, color, theme):\n    \"\"\"Create a histogram from user data\"\"\"\n    if not var or df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.histplot(data=df, x=var, kde=True, color=color, ax=ax)\n    ax.set_title(f\"{var}\")\n    ax.set_xlabel(var.replace(\"_\", \" \").title())\n    ax.set_ylabel(\"Count\")\n    \n    return ax", "type": "text"}, {"name": "plots/lineplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef create_lineplot(input_lineplot_type, input_lineplot_color, theme):\n    \"\"\"Create a line plot based on input parameters\"\"\"\n    lineplot_type = input_lineplot_type\n    color = color_palettes[input_lineplot_color]\n\n    x = np.linspace(0, 10, 20)  # Reduced number of points\n    if lineplot_type == \"Linear Trend\":\n        y = 2 * x + 1 + np.random.normal(0, 1, 20)\n    elif lineplot_type == \"Exponential Growth\":\n        y = np.exp(0.5 * x) + np.random.normal(0, 1, 20)\n    elif lineplot_type == \"Sinusoidal Pattern\":\n        y = 5 * np.sin(x) + np.random.normal(0, 0.5, 20)\n    elif lineplot_type == \"Random Walk\":\n        y = np.cumsum(np.random.normal(0, 1, 20))\n    else:\n        y = x + np.random.normal(0, 1, 20)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.lineplot(x=x, y=y, ax=ax, color=color)\n    ax.set_title(f\"{lineplot_type}\")\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n\n    return ax\n\ndef create_custom_lineplot(df, var_x, var_y, color, theme):\n    \"\"\"Create a line plot from user data\"\"\"\n    if not var_x or not var_y or df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    sns.lineplot(data=df, x=var_x, y=var_y, color=color, ax=ax)\n    ax.set_title(f\"{var_y} vs {var_x}\")\n    ax.set_xlabel(var_x.replace(\"_\", \" \").title())\n    ax.set_ylabel(var_y.replace(\"_\", \" \").title())\n    \n    return ax", "type": "text"}, {"name": "plots/multilayerplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef generate_multilayer_data():\n    \"\"\"Generate sample data for the multilayer plot\"\"\"\n    x = np.arange(8)\n    bar_data = np.array([3, 5, 2, 7, 3, 6, 4, 5])\n    hist_data = np.concatenate([np.random.normal(loc=i, scale=0.5, size=20) for i in x])\n    scatter_data = np.array([4, 6, 3, 8, 2, 7, 5, 6])\n    line_data = np.array([10, 8, 12, 14, 9, 11, 13, 10])\n    \n    # Create a dictionary with the generated data\n    return {\n        \"x\": x,\n        \"bar_data\": bar_data,\n        \"hist_data\": hist_data,\n        \"scatter_data\": scatter_data,\n        \"line_data\": line_data\n    }\n\ndef create_multilayer_plot(input_background_type, background_color, line_color, theme):\n    \"\"\"\n    Create a multilayer plot with a selected background plot type and a line chart in the foreground.\n    \n    Parameters\n    ----------\n    input_background_type : str\n        The type of background plot ('Bar Plot', 'Histogram', or 'Scatter Plot')\n    background_color : str\n        The color to use for the background plot\n    line_color : str\n        The color to use for the line plot\n    theme : str\n        The theme to apply to the plot ('Light' or 'Dark')\n        \n    Returns\n    -------\n    plt.Axes\n        The axes object of the created plot.\n    \"\"\"\n    # Generate sample data\n    data = generate_multilayer_data()\n    x = data[\"x\"]\n    bar_data = data[\"bar_data\"]\n    hist_data = data[\"hist_data\"]\n    scatter_data = data[\"scatter_data\"]\n    line_data = data[\"line_data\"]\n    \n    # Create a figure and a set of subplots\n    fig, ax1 = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax1, theme)\n    \n    # Get colors from the color_palettes dictionary or use default if not found\n    bg_color = color_palettes.get(background_color, \"skyblue\")\n    ln_color = color_palettes.get(line_color, \"red\")\n    \n    # Create the background plot based on the selected type\n    if input_background_type == \"Bar Plot\":\n        ax1.bar(x, bar_data, color=bg_color, label=\"Bar Data\", alpha=0.7)\n        ax1.set_ylabel(\"Bar Values\", color=bg_color)\n        y_min, y_max = 0, max(bar_data) * 1.2\n    \n    elif input_background_type == \"Histogram\":\n        # For histogram, we need to adjust the scale to fit with line plot\n        bins = np.linspace(min(hist_data), max(hist_data), 20)\n        ax1.hist(hist_data, bins=bins, color=bg_color, label=\"Histogram Data\", alpha=0.7)\n        ax1.set_ylabel(\"Frequency\", color=bg_color)\n        y_min, y_max = 0, ax1.get_ylim()[1] * 1.2\n    \n    elif input_background_type == \"Scatter Plot\":\n        ax1.scatter(x, scatter_data, color=bg_color, label=\"Scatter Data\", alpha=0.7, s=100)\n        ax1.set_ylabel(\"Y Values\", color=bg_color)\n        y_min, y_max = min(scatter_data) * 0.8, max(scatter_data) * 1.2\n    \n    ax1.tick_params(axis=\"y\", labelcolor=bg_color)\n    ax1.set_xlabel(\"X Values\")\n    \n    # Set y-axis limits for the background plot\n    ax1.set_ylim(y_min, y_max)\n    \n    # Create a second y-axis sharing the same x-axis\n    ax2 = ax1.twinx()\n    \n    # Create the line chart on the second y-axis\n    ax2.plot(x, line_data, color=ln_color, marker=\"o\", linestyle=\"-\", linewidth=2, label=\"Line Data\")\n    ax2.set_ylabel(\"Line Values\", color=ln_color)\n    ax2.tick_params(axis=\"y\", labelcolor=ln_color)\n    \n    # Add title\n    ax1.set_title(f\"Multilayer Plot: {input_background_type} with Line Plot\")\n    \n    # Add legends for both axes\n    lines1, labels1 = ax1.get_legend_handles_labels()\n    lines2, labels2 = ax2.get_legend_handles_labels()\n    ax1.legend(lines1 + lines2, labels1 + labels2, loc=\"upper left\")\n    \n    # Adjust layout\n    fig.tight_layout()\n    \n    return ax1\n\ndef create_custom_multilayer_plot(df, var_x, var_background, var_line, background_type, background_color, line_color, theme):\n    \"\"\"\n    Create a custom multilayer plot from user data.\n    \n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The dataframe containing the data to plot\n    var_x : str\n        The name of the column to use for the x-axis\n    var_background : str\n        The name of the column to use for the background plot\n    var_line : str\n        The name of the column to use for the line chart\n    background_type : str\n        The type of background plot ('Bar Plot', 'Histogram', or 'Scatter Plot')\n    background_color : str\n        The color to use for the background plot\n    line_color : str\n        The color to use for the line plot\n    theme : str\n        The theme to apply to the plot ('Light' or 'Dark')\n        \n    Returns\n    -------\n    plt.Axes\n        The axes object of the created plot.\n    \"\"\"\n    if not var_x or not var_background or not var_line or df is None:\n        return None\n    \n    # Create a figure and a set of subplots\n    fig, ax1 = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax1, theme)\n    \n    # Get data from dataframe\n    x = df[var_x].values\n    background_data = df[var_background].values\n    line_data = df[var_line].values\n    \n    # Get colors from the color_palettes dictionary or use default if not found\n    bg_color = color_palettes.get(background_color, \"skyblue\")\n    ln_color = color_palettes.get(line_color, \"red\")\n    \n    # Create the background plot based on the selected type\n    if background_type == \"Bar Plot\":\n        # For categorical x, we may need to handle the x-axis differently\n        if df[var_x].dtype == 'object':\n            x_positions = np.arange(len(x))\n            ax1.bar(x_positions, background_data, color=bg_color, label=var_background, alpha=0.7)\n            ax1.set_xticks(x_positions)\n            ax1.set_xticklabels(x)\n        else:\n            ax1.bar(x, background_data, color=bg_color, label=var_background, alpha=0.7)\n        \n        ax1.set_ylabel(var_background.replace(\"_\", \" \").title(), color=bg_color)\n        y_min, y_max = 0, max(background_data) * 1.2\n    \n    elif background_type == \"Histogram\":\n        # For histogram, we just use the background data column\n        bins = np.linspace(min(background_data), max(background_data), 20)\n        ax1.hist(background_data, bins=bins, color=bg_color, label=var_background, alpha=0.7)\n        ax1.set_ylabel(\"Frequency\", color=bg_color)\n        y_min, y_max = 0, ax1.get_ylim()[1] * 1.2\n    \n    elif background_type == \"Scatter Plot\":\n        # For categorical x, we may need to handle the x-axis differently\n        if df[var_x].dtype == 'object':\n            x_positions = np.arange(len(x))\n            ax1.scatter(x_positions, background_data, color=bg_color, label=var_background, alpha=0.7, s=100)\n            ax1.set_xticks(x_positions)\n            ax1.set_xticklabels(x)\n        else:\n            ax1.scatter(x, background_data, color=bg_color, label=var_background, alpha=0.7, s=100)\n            \n        ax1.set_ylabel(var_background.replace(\"_\", \" \").title(), color=bg_color)\n        y_min, y_max = min(background_data) * 0.8, max(background_data) * 1.2\n    \n    ax1.tick_params(axis=\"y\", labelcolor=bg_color)\n    ax1.set_xlabel(var_x.replace(\"_\", \" \").title())\n    \n    # Set y-axis limits for the background plot\n    ax1.set_ylim(y_min, y_max)\n    \n    # Create a second y-axis sharing the same x-axis\n    ax2 = ax1.twinx()\n    \n    # Create the line chart on the second y-axis\n    # For categorical x, we may need to handle the x-axis differently\n    if df[var_x].dtype == 'object' and background_type != \"Histogram\":\n        x_positions = np.arange(len(x))\n        ax2.plot(x_positions, line_data, color=ln_color, marker=\"o\", linestyle=\"-\", linewidth=2, label=var_line)\n    else:\n        ax2.plot(x, line_data, color=ln_color, marker=\"o\", linestyle=\"-\", linewidth=2, label=var_line)\n        \n    ax2.set_ylabel(var_line.replace(\"_\", \" \").title(), color=ln_color)\n    ax2.tick_params(axis=\"y\", labelcolor=ln_color)\n    \n    # Add title\n    ax1.set_title(f\"{var_background} ({background_type}) and {var_line} vs {var_x}\")\n    \n    # Add legends for both axes\n    lines1, labels1 = ax1.get_legend_handles_labels()\n    lines2, labels2 = ax2.get_legend_handles_labels()\n    ax1.legend(lines1 + lines2, labels1 + labels2, loc=\"upper left\")\n    \n    # Adjust layout\n    fig.tight_layout()\n    \n    return ax1", "type": "text"}, {"name": "plots/multilineplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport pandas as pd\nfrom plots.utils import set_plot_theme\n\ndef generate_multiline_data(multiline_type):\n    \"\"\"Generate data for multiline plots based on the selected type\"\"\"\n    x = np.linspace(0, 10, 30)  # 30 points for x-axis\n    series_names = [\"Series 1\", \"Series 2\", \"Series 3\"]\n    \n    if multiline_type == \"Simple Trends\":\n        # Linear trends with different slopes\n        y1 = 1.5 * x + np.random.normal(0, 1, 30)\n        y2 = 0.5 * x + 5 + np.random.normal(0, 1, 30)\n        y3 = -x + 15 + np.random.normal(0, 1, 30)\n    elif multiline_type == \"Seasonal Patterns\":\n        # Sinusoidal patterns with different phases\n        y1 = 5 * np.sin(x) + 10 + np.random.normal(0, 0.5, 30)\n        y2 = 5 * np.sin(x + np.pi/2) + 10 + np.random.normal(0, 0.5, 30)\n        y3 = 5 * np.sin(x + np.pi) + 10 + np.random.normal(0, 0.5, 30)\n    elif multiline_type == \"Growth Comparison\":\n        # Different growth patterns\n        y1 = np.exp(0.2 * x) + np.random.normal(0, 0.5, 30)\n        y2 = x**2 / 10 + np.random.normal(0, 1, 30)\n        y3 = np.log(x + 1) * 5 + np.random.normal(0, 0.5, 30)\n    else:  # Random Series\n        # Random walks with different volatilities\n        y1 = np.cumsum(np.random.normal(0, 0.5, 30))\n        y2 = np.cumsum(np.random.normal(0.1, 0.7, 30))\n        y3 = np.cumsum(np.random.normal(-0.05, 0.9, 30))\n    \n    # Create a dataframe with the generated data\n    return pd.DataFrame({\n        \"x\": np.tile(x, 3),\n        \"y\": np.concatenate([y1, y2, y3]),\n        \"series\": np.repeat(series_names, len(x))\n    })\n\ndef create_multiline_plot(data, input_multiline_type, input_multiline_color, theme):\n    \"\"\"Create a multiline plot based on input parameters and data\"\"\"\n    multiline_type = input_multiline_type\n    palette = input_multiline_color\n    \n    # Map friendly palette names to seaborn palette names\n    palette_mapping = {\n        \"Default\": None,  # Use default seaborn palette\n        \"Colorful\": \"Set1\",\n        \"Pastel\": \"Set2\",\n        \"Dark Tones\": \"Dark2\",\n        \"Paired Colors\": \"Paired\",\n        \"Rainbow\": \"Spectral\"\n    }\n    \n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    # Use seaborn lineplot for multiple lines\n    if palette == \"Default\":\n        # Use default seaborn color palette\n        sns.lineplot(\n            x=\"x\", y=\"y\", hue=\"series\", style=\"series\", \n            markers=True, dashes=True, data=data, ax=ax\n        )\n    else:\n        # Use selected color palette\n        sns.lineplot(\n            x=\"x\", y=\"y\", hue=\"series\", style=\"series\", \n            markers=True, dashes=True, data=data, ax=ax,\n            palette=palette_mapping[palette]\n        )\n    \n    # Customize the plot\n    ax.set_title(f\"Multiline Plot: {multiline_type}\")\n    ax.set_xlabel(\"X values\")\n    ax.set_ylabel(\"Y values\")\n    \n    return ax\n\ndef create_custom_multiline_plot(df, var_x, var_y, var_group, palette, theme):\n    \"\"\"Create a multiline plot from user data\"\"\"\n    if not var_x or not var_y or not var_group or df is None:\n        return None\n    \n    # Map friendly palette names to seaborn palette names\n    palette_mapping = {\n        \"Default\": None,  # Use default seaborn palette\n        \"Colorful\": \"Set1\",\n        \"Pastel\": \"Set2\",\n        \"Dark Tones\": \"Dark2\",\n        \"Paired Colors\": \"Paired\",\n        \"Rainbow\": \"Spectral\"\n    }\n    \n    # Create the plot\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    # Use seaborn lineplot for multiple lines\n    if palette == \"Default\":\n        # Use default seaborn color palette\n        sns.lineplot(\n            x=var_x, y=var_y, hue=var_group, style=var_group, \n            markers=True, dashes=True, data=df, ax=ax\n        )\n    else:\n        # Use selected color palette\n        sns.lineplot(\n            x=var_x, y=var_y, hue=var_group, style=var_group, \n            markers=True, dashes=True, data=df, ax=ax,\n            palette=palette_mapping[palette]\n        )\n    \n    # Customize the plot\n    ax.set_title(f\"{var_y} vs {var_x} by {var_group}\")\n    ax.set_xlabel(var_x.replace(\"_\", \" \").title())\n    ax.set_ylabel(var_y.replace(\"_\", \" \").title())\n    \n    return ax", "type": "text"}, {"name": "plots/multipanelplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom plots.utils import set_plot_theme\n\ndef generate_multipanel_data():\n    \"\"\"Generate sample data for the multipanel plot\"\"\"\n    # Data for line plot\n    x_line = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n    y_line = np.array([2, 4, 1, 5, 3, 7, 6, 8])\n    \n    # Data for first bar plot\n    categories = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    values = np.random.rand(5) * 10\n    \n    # Data for second bar plot\n    categories_2 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    values_2 = np.random.randn(5) * 100\n    \n    # Data for scatter plot\n    x_scatter = np.random.randn(50)\n    y_scatter = np.random.randn(50)\n    \n    # Create a dictionary with the generated data\n    return {\n        \"x_line\": x_line,\n        \"y_line\": y_line,\n        \"categories\": categories,\n        \"values\": values,\n        \"categories_2\": categories_2,\n        \"values_2\": values_2,\n        \"x_scatter\": x_scatter,\n        \"y_scatter\": y_scatter\n    }\n\ndef create_multipanel_plot(layout_type, color_palette, theme):\n    \"\"\"\n    Create a multipanel plot with different subplot types arranged in a specified layout.\n    \n    Parameters\n    ----------\n    layout_type : str\n        The type of layout ('Grid 2x2', 'Row', 'Column', 'Mixed')\n    color_palette : str\n        The color palette to use for the plots\n    theme : str\n        The theme to apply to the plot ('Light' or 'Dark')\n        \n    Returns\n    -------\n    plt.Axes\n        The first axes object of the created plot (for maidr compatibility).\n    \"\"\"\n    # Generate sample data\n    data = generate_multipanel_data()\n    x_line = data[\"x_line\"]\n    y_line = data[\"y_line\"]\n    categories = data[\"categories\"]\n    values = data[\"values\"]\n    categories_2 = data[\"categories_2\"]\n    values_2 = data[\"values_2\"]\n    x_scatter = data[\"x_scatter\"]\n    y_scatter = data[\"y_scatter\"]\n    \n    # Create a figure with 3 subplots arranged vertically\n    fig, axs = plt.subplots(3, 1, figsize=(10, 12))\n    \n    # First panel: Line plot\n    axs[0].plot(x_line, y_line, color=\"blue\", linewidth=2)\n    axs[0].set_title(\"Line Plot: Random Data\")\n    axs[0].set_xlabel(\"X-axis\")\n    axs[0].set_ylabel(\"Values\")\n    axs[0].grid(True, linestyle=\"--\", alpha=0.7)\n    \n    # Second panel: Bar plot\n    axs[1].bar(categories, values, color=\"green\", alpha=0.7)\n    axs[1].set_title(\"Bar Plot: Random Values\")\n    axs[1].set_xlabel(\"Categories\")\n    axs[1].set_ylabel(\"Values\")\n    \n    # Third panel: Bar plot\n    axs[2].bar(categories_2, values_2, color=\"blue\", alpha=0.7)\n    axs[2].set_title(\"Bar Plot 2: Random Values\")\n    axs[2].set_xlabel(\"Categories\")\n    axs[2].set_ylabel(\"Values\")\n    \n    # Apply theme to all subplots\n    for ax in axs.flat:\n        set_plot_theme(fig, ax, theme)\n    \n    # Adjust layout to prevent overlap\n    plt.tight_layout()\n    \n    # Return the first axes object for maidr compatibility\n    return axs[0]\n\ndef create_custom_multipanel_plot(df, vars_config, layout_type, color_palette, theme):\n    \"\"\"\n    Create a custom multipanel plot from user data.\n    \n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The dataframe containing the data to plot\n    vars_config : dict\n        Dictionary containing variables for each subplot\n        Example: {\n            'plot1': {'type': 'line', 'x': 'col1', 'y': 'col2'},\n            'plot2': {'type': 'bar', 'x': 'col3', 'y': 'col4'},\n            'plot3': {'type': 'bar', 'x': 'col5', 'y': 'col6'},\n        }\n    layout_type : str\n        The type of layout ('Vertical', 'Horizontal', 'Grid')\n    color_palette : str\n        The color palette to use for the plots\n    theme : str\n        The theme to apply to the plot ('Light' or 'Dark')\n        \n    Returns\n    -------\n    plt.Axes\n        The first axes object of the created plot (for maidr compatibility).\n    \"\"\"\n    if df is None or not vars_config:\n        return None\n    \n    # Extract configuration for each plot\n    plot1_config = vars_config.get('plot1', {})\n    plot2_config = vars_config.get('plot2', {})\n    plot3_config = vars_config.get('plot3', {})\n    \n    plot1_type = plot1_config.get('type', 'line')\n    plot1_x = plot1_config.get('x', None)\n    plot1_y = plot1_config.get('y', None)\n    \n    plot2_type = plot2_config.get('type', 'bar')\n    plot2_x = plot2_config.get('x', None)\n    plot2_y = plot2_config.get('y', None)\n    \n    plot3_type = plot3_config.get('type', 'bar')\n    plot3_x = plot3_config.get('x', None)\n    plot3_y = plot3_config.get('y', None)\n    \n    # Check if required variables exist\n    if not all([plot1_x, plot1_y, plot2_x, plot2_y, plot3_x, plot3_y]):\n        return None\n    \n    if not all([var in df.columns for var in [plot1_x, plot1_y, plot2_x, plot2_y, plot3_x, plot3_y]]):\n        return None\n    \n    # Create the figure with 3 subplots arranged vertically\n    fig, axs = plt.subplots(3, 1, figsize=(10, 12))\n    \n    # First panel\n    if plot1_type == 'line':\n        axs[0].plot(df[plot1_x], df[plot1_y], color=\"blue\", linewidth=2)\n        axs[0].set_title(f\"Line Plot: {plot1_y} vs {plot1_x}\")\n        axs[0].grid(True, linestyle=\"--\", alpha=0.7)\n    elif plot1_type == 'scatter':\n        axs[0].scatter(df[plot1_x], df[plot1_y], color=\"blue\", alpha=0.7)\n        axs[0].set_title(f\"Scatter Plot: {plot1_y} vs {plot1_x}\")\n    elif plot1_type == 'bar':\n        if df[plot1_x].dtype == 'object' or df[plot1_x].nunique() < 15:\n            # For categorical x or small number of values\n            value_counts = df.groupby(plot1_x)[plot1_y].mean()\n            value_counts.plot(kind='bar', ax=axs[0], color=\"blue\", alpha=0.7)\n        else:\n            axs[0].bar(df[plot1_x], df[plot1_y], color=\"blue\", alpha=0.7)\n        axs[0].set_title(f\"Bar Plot: {plot1_y} by {plot1_x}\")\n    \n    axs[0].set_xlabel(plot1_x.replace(\"_\", \" \").title())\n    axs[0].set_ylabel(plot1_y.replace(\"_\", \" \").title())\n    \n    # Second panel\n    if plot2_type == 'line':\n        axs[1].plot(df[plot2_x], df[plot2_y], color=\"green\", linewidth=2)\n        axs[1].set_title(f\"Line Plot: {plot2_y} vs {plot2_x}\")\n        axs[1].grid(True, linestyle=\"--\", alpha=0.7)\n    elif plot2_type == 'scatter':\n        axs[1].scatter(df[plot2_x], df[plot2_y], color=\"green\", alpha=0.7)\n        axs[1].set_title(f\"Scatter Plot: {plot2_y} vs {plot2_x}\")\n    elif plot2_type == 'bar':\n        if df[plot2_x].dtype == 'object' or df[plot2_x].nunique() < 15:\n            # For categorical x or small number of values\n            value_counts = df.groupby(plot2_x)[plot2_y].mean()\n            value_counts.plot(kind='bar', ax=axs[1], color=\"green\", alpha=0.7)\n        else:\n            axs[1].bar(df[plot2_x], df[plot2_y], color=\"green\", alpha=0.7)\n        axs[1].set_title(f\"Bar Plot: {plot2_y} by {plot2_x}\")\n    \n    axs[1].set_xlabel(plot2_x.replace(\"_\", \" \").title())\n    axs[1].set_ylabel(plot2_y.replace(\"_\", \" \").title())\n    \n    # Third panel\n    if plot3_type == 'line':\n        axs[2].plot(df[plot3_x], df[plot3_y], color=\"blue\", linewidth=2)\n        axs[2].set_title(f\"Line Plot: {plot3_y} vs {plot3_x}\")\n        axs[2].grid(True, linestyle=\"--\", alpha=0.7)\n    elif plot3_type == 'scatter':\n        axs[2].scatter(df[plot3_x], df[plot3_y], color=\"blue\", alpha=0.7)\n        axs[2].set_title(f\"Scatter Plot: {plot3_y} vs {plot3_x}\")\n    elif plot3_type == 'bar':\n        if df[plot3_x].dtype == 'object' or df[plot3_x].nunique() < 15:\n            # For categorical x or small number of values\n            value_counts = df.groupby(plot3_x)[plot3_y].mean()\n            value_counts.plot(kind='bar', ax=axs[2], color=\"blue\", alpha=0.7)\n        else:\n            axs[2].bar(df[plot3_x], df[plot3_y], color=\"blue\", alpha=0.7)\n        axs[2].set_title(f\"Bar Plot: {plot3_y} by {plot3_x}\")\n    \n    axs[2].set_xlabel(plot3_x.replace(\"_\", \" \").title())\n    axs[2].set_ylabel(plot3_y.replace(\"_\", \" \").title())\n    \n    # Apply theme to all subplots\n    for ax in axs.flat:\n        set_plot_theme(fig, ax, theme)\n    \n    # Adjust layout to prevent overlap\n    plt.tight_layout()\n    \n    # Return the first axes object for maidr compatibility\n    return axs[0]", "type": "text"}, {"name": "plots/scatterplot.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom plots.utils import set_plot_theme, color_palettes\n\ndef create_scatterplot(input_scatterplot_type, input_scatter_color, theme):\n    \"\"\"Create a scatter plot with regression layers based on input parameters\"\"\"\n    scatterplot_type = input_scatterplot_type\n    color = color_palettes[input_scatter_color]\n\n    num_points = np.random.randint(20, 31)  # Randomly select between 20 and 30 points\n    if scatterplot_type == \"No Correlation\":\n        x = np.random.uniform(size=num_points)\n        y = np.random.uniform(size=num_points)\n    elif scatterplot_type == \"Weak Positive Correlation\":\n        x = np.random.uniform(size=num_points)\n        y = 0.3 * x + np.random.uniform(size=num_points)\n    elif scatterplot_type == \"Strong Positive Correlation\":\n        x = np.random.uniform(size=num_points)\n        y = 0.9 * x + np.random.uniform(size=num_points) * 0.1\n    elif scatterplot_type == \"Weak Negative Correlation\":\n        x = np.random.uniform(size=num_points)\n        y = -0.3 * x + np.random.uniform(size=num_points)\n    elif scatterplot_type == \"Strong Negative Correlation\":\n        x = np.random.uniform(size=num_points)\n        y = -0.9 * x + np.random.uniform(size=num_points) * 0.1\n    else:\n        x = np.random.uniform(size=num_points)\n        y = np.random.uniform(size=num_points)\n\n    # Create the plot using matplotlib\n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    # Ensure clean white background (remove any pink tinting)\n    if theme != \"Dark\":\n        ax.set_facecolor('white')\n        fig.patch.set_facecolor('white')\n    \n    # Layer 1: Scatter points (original layer)\n    sns.scatterplot(x=x, y=y, ax=ax, color=color, s=60, alpha=0.7, label=\"Data Points\")\n    \n    # Layer 2: Best fit straight line (linear regression)\n    sns.regplot(x=x, y=y, ax=ax, scatter=False, color=\"red\", \n                line_kws={'linewidth': 2, 'alpha': 0.8}, label=\"Linear Fit\",\n                ci=None)  # Remove confidence interval to avoid pink shading\n    \n    # Layer 3: Loess smooth line (LOWESS regression)\n    sns.regplot(x=x, y=y, ax=ax, scatter=False, lowess=True, color=\"blue\",\n                line_kws={'linewidth': 2, 'alpha': 0.8, 'linestyle': '--'}, label=\"LOESS Smooth\",\n                ci=None)  # Remove confidence interval to avoid pink shading\n    \n    ax.set_title(f\"{scatterplot_type}\")\n    ax.set_xlabel(\"X\")\n    ax.set_ylabel(\"Y\")\n    ax.legend()\n\n    return ax\n\ndef create_custom_scatterplot(df, var_x, var_y, color, theme):\n    \"\"\"Create a scatter plot with regression layers from user data\"\"\"\n    if not var_x or not var_y or df is None:\n        return None\n        \n    fig, ax = plt.subplots(figsize=(10, 6))\n    set_plot_theme(fig, ax, theme)\n    \n    # Ensure clean white background (remove any pink tinting)\n    if theme != \"Dark\":\n        ax.set_facecolor('white')\n        fig.patch.set_facecolor('white')\n    \n    # Layer 1: Scatter points (original layer)\n    sns.scatterplot(data=df, x=var_x, y=var_y, color=color, ax=ax, \n                    s=60, alpha=0.7, label=\"Data Points\")\n    \n    # Layer 2: Best fit straight line (linear regression)\n    sns.regplot(data=df, x=var_x, y=var_y, ax=ax, scatter=False, color=\"red\",\n                line_kws={'linewidth': 2, 'alpha': 0.8}, label=\"Linear Fit\",\n                ci=None)  # Remove confidence interval to avoid pink shading\n    \n    # Layer 3: Loess smooth line (LOWESS regression)\n    sns.regplot(data=df, x=var_x, y=var_y, ax=ax, scatter=False, lowess=True, color=\"blue\",\n                line_kws={'linewidth': 2, 'alpha': 0.8, 'linestyle': '--'}, label=\"LOESS Smooth\",\n                ci=None)  # Remove confidence interval to avoid pink shading\n    \n    ax.set_title(f\"{var_y} vs {var_x}\")\n    ax.set_xlabel(var_x.replace(\"_\", \" \").title())\n    ax.set_ylabel(var_y.replace(\"_\", \" \").title())\n    ax.legend()\n    \n    return ax", "type": "text"}, {"name": "plots/utils.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n\ndef set_plot_theme(fig, ax, theme):\n    \"\"\"Apply the appropriate theme to a plot\"\"\"\n    if theme == \"Dark\":\n        plt.style.use(\"dark_background\")\n        fig.patch.set_facecolor(\"#2E2E2E\")\n        ax.set_facecolor(\"#2E2E2E\")\n    else:\n        plt.style.use(\"default\")\n        fig.patch.set_facecolor(\"white\")\n        ax.set_facecolor(\"white\")\n        \n# Dictionary of color palettes\ncolor_palettes = {\n    \"Default\": \"#007bc2\",\n    \"Red\": \"#FF0000\",\n    \"Green\": \"#00FF00\",\n    \"Blue\": \"#0000FF\",\n    \"Purple\": \"#800080\",\n    \"Orange\": \"#FFA500\",\n}", "type": "text"}]